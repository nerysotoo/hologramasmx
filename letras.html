<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR con Texto Animado</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #1a1a2e;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
      }

      .container {
        position: relative;
        width: 90%;
        max-width: 600px;
      }

      canvas {
        width: 100%;
        border-radius: 10px;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        display: block;
        background: #000;
      }

      #info {
        position: absolute;
        top: 15px;
        left: 15px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        padding: 15px;
        border-radius: 8px;
        border: 2px solid #00ffff;
        font-size: 13px;
        z-index: 10;
        max-width: 250px;
      }

      #info h3 {
        margin-bottom: 8px;
        text-shadow: 0 0 5px #00ffff;
      }

      .status {
        margin: 5px 0;
        font-size: 12px;
      }

      .status.detected {
        color: #00ff00;
      }

      .status.not-detected {
        color: #ff4444;
      }

      #controls {
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 12px 20px;
        border-radius: 8px;
        border: 2px solid #00ffff;
        z-index: 10;
      }

      button {
        background: linear-gradient(135deg, #00ffff, #00ccff);
        border: none;
        padding: 10px 20px;
        margin: 0 5px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        color: #000;
        transition: all 0.3s;
        font-size: 12px;
      }

      button:hover {
        transform: scale(1.05);
      }

      .slider-container {
        position: absolute;
        top: 15px;
        right: 15px;
        background: rgba(0, 0, 0, 0.8);
        padding: 12px;
        border-radius: 8px;
        border: 2px solid #00ffff;
        z-index: 10;
      }

      .slider-container label {
        color: #00ffff;
        display: block;
        font-size: 12px;
        margin-bottom: 5px;
      }

      input[type="range"] {
        width: 120px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="canvas"></canvas>

      <div id="info">
        <h3>AR + Texto Animado</h3>
        <div class="status" id="statusDetection">üîç Escaneando...</div>
        <div style="margin-top: 10px; font-size: 11px; color: #ccc">
          √Årea detectada: <span id="areaValue">0</span>%
        </div>
      </div>

      <div class="slider-container">
        <label>Sensibilidad:</label>
        <input type="range" id="sensitivity" min="10" max="100" value="50" />
      </div>

      <div id="controls">
        <button onclick="toggleMode()">üîÑ Modo</button>
        <button onclick="togglePause()">‚è∏ Pausar</button>
        <button onclick="toggleText()">üìù Texto</button>
      </div>
    </div>

    <video id="video" style="display: none"></video>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const video = document.getElementById("video");

      canvas.width = 600;
      canvas.height = 450;

      let time = 0;
      let paused = false;
      let mode = 0;
      let showText = true;

      const animatedTexts = [
        {
          text: "üåå REALIDAD AUMENTADA",
          y: 50,
          fontSize: 24,
          color: "#00ffff",
          animation: "float",
        },
        {
          text: "Detecci√≥n de Espacios",
          y: 420,
          fontSize: 18,
          color: "#ff00ff",
          animation: "typewriter",
        },
        {
          text: "Holograma Activo",
          x: 10,
          y: 350,
          fontSize: 14,
          color: "#00ff00",
          animation: "pulse",
        },
      ];

      async function startCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
          });
          video.srcObject = stream;
          video.onloadedmetadata = () => {
            video.play();
            mainLoop();
          };
        } catch (error) {
          alert("Error: " + error.message);
        }
      }

      function detectEmptySpace() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        let emptyPixels = 0;
        let totalPixels = data.length / 4;

        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const brightness = (r + g + b) / 3;

          let isEmpty = false;
          if (mode === 0) {
            isEmpty = brightness < 100;
          } else {
            isEmpty = brightness > 150;
          }

          if (isEmpty) emptyPixels++;
        }

        const percentage = (emptyPixels / totalPixels) * 100;
        return percentage;
      }

      function findBestPosition() {
        const zoneWidth = canvas.width / 3;
        const zoneHeight = canvas.height / 3;

        let bestZone = null;
        let maxEmptyPixels = 0;

        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const x = col * zoneWidth;
            const y = row * zoneHeight;

            const imageData = ctx.getImageData(x, y, zoneWidth, zoneHeight);
            const data = imageData.data;

            let emptyCount = 0;
            for (let i = 0; i < data.length; i += 4) {
              const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
              let isEmpty = mode === 0 ? brightness < 100 : brightness > 150;
              if (isEmpty) emptyCount++;
            }

            if (emptyCount > maxEmptyPixels) {
              maxEmptyPixels = emptyCount;
              bestZone = {
                x: x + zoneWidth / 2,
                y: y + zoneHeight / 2,
                col,
                row,
              };
            }
          }
        }

        return bestZone;
      }

      function drawHologramAtPosition(position) {
        if (!position) return;

        const { x, y } = position;
        const size = 40;

        const pulse = Math.sin(time * 0.05) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(0, 255, 255, ${0.2 * pulse})`;
        ctx.beginPath();
        ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgb(0, 255, 255)";
        ctx.lineWidth = 2;
        for (let i = 1; i <= 2; i++) {
          ctx.beginPath();
          ctx.arc(x, y, size * i * 0.4, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(time * 0.03);
        ctx.fillStyle = "rgba(0, 255, 255, 0.8)";
        ctx.beginPath();
        const points = [
          [0, -size],
          [size, 0],
          [0, size],
          [-size, 0],
        ];
        ctx.moveTo(points[0][0], points[0][1]);
        points.forEach((p) => ctx.lineTo(p[0], p[1]));
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(x - size * 2, y - size * 2, size * 4, size * 4);
        ctx.setLineDash([]);
      }

      function drawFloatingText(text, y, fontSize, color) {
        const offset = Math.sin(time * 0.02) * 10;

        ctx.fillStyle = color;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.fillText(text, canvas.width / 2, y + offset);

        ctx.shadowBlur = 0;
      }

      function drawTypewriterText(text, y, fontSize, color) {
        const cycleTime = 2000; // Ciclo de 2 segundos
        const timeInCycle = (time * 16) % cycleTime; // 16ms por frame
        const charsToShow = Math.floor((timeInCycle / cycleTime) * text.length);
        const displayText = text.substring(0, charsToShow);

        ctx.fillStyle = color;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;

        ctx.fillText(displayText, canvas.width / 2, y);

        if (time % 20 < 10) {
          ctx.fillText(
            "|",
            canvas.width / 2 + displayText.length * (fontSize * 0.6),
            y
          );
        }

        ctx.shadowBlur = 0;
      }

      function drawPulseText(text, x, y, fontSize, color) {
        const pulse = Math.sin(time * 0.08) * 0.5 + 0.5; // 0 a 1
        const alpha = (pulse * 0.7 + 0.3).toFixed(2); // 0.3 a 1.0

        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = "left";
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;

        ctx.fillText(text, x, y);

        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
      }

      function drawAnimatedTexts() {
        if (!showText) return;

        animatedTexts.forEach((textObj) => {
          switch (textObj.animation) {
            case "float":
              drawFloatingText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            case "typewriter":
              drawTypewriterText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            case "pulse":
              drawPulseText(
                textObj.text,
                textObj.x,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
              break;
            default:
              drawFloatingText(
                textObj.text,
                textObj.y,
                textObj.fontSize,
                textObj.color
              );
          }
        });
      }

      function mainLoop() {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const emptyPercentage = detectEmptySpace();
        const bestPosition = findBestPosition();

        if (bestPosition) {
          drawHologramAtPosition(bestPosition);
        }

        drawAnimatedTexts();

        document.getElementById("areaValue").textContent =
          emptyPercentage.toFixed(1);

        const statusEl = document.getElementById("statusDetection");
        if (emptyPercentage > 30) {
          statusEl.className = "status detected";
          statusEl.textContent = "Espacio detectado";
        } else {
          statusEl.className = "status not-detected";
          statusEl.textContent = " Buscando espacio...";
        }

        if (!paused) time++;

        requestAnimationFrame(mainLoop);
      }

      function toggleMode() {
        mode = (mode + 1) % 2;
        const modeNames = ["Oscuro (piso/sombra)", "Brillante (pared)"];
        console.log("Modo:", modeNames[mode]);
      }

      function togglePause() {
        paused = !paused;
        document.querySelector("button:nth-child(2)").textContent = paused
          ? "‚ñ∂ Reanudar"
          : "‚è∏ Pausar";
      }

      function toggleText() {
        showText = !showText;
        document.querySelector("button:nth-child(3)").textContent = showText
          ? "üìù Texto"
          : "üìù Off";
      }

      document.getElementById("sensitivity").addEventListener("input", (e) => {
        console.log("Sensibilidad:", e.target.value);
      });

      startCamera();
    </script>
  </body>
</html>
